You are an expert developer assistant. Below is the complete context of a project. Please analyze it thoroughly and provide accurate assistance.

PROJECT CONTEXT:
ðŸ¤– PROJECT CONTEXT FOR AI ASSISTANCE
============================================================
PROJECT: mytools
SELECTION MODE: SMART
GENERATED: 2026-02-14 13:37:50
============================================================

ðŸ“ PROJECT STRUCTURE:
Project Tree:
â”œâ”€â”€ ðŸ“ src
â”‚   â””â”€â”€ ðŸ“ mytools
â”‚       â”œâ”€â”€ ðŸ“ plugins
â”‚       â”œâ”€â”€ ðŸ“ tools
â”‚       â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚       â”‚   â”œâ”€â”€ ðŸ“„ base.py
â”‚       â”‚   â”œâ”€â”€ ðŸ“„ clean_pycache.py
â”‚       â”‚   â”œâ”€â”€ ðŸ“„ context_generator.py
â”‚       â”‚   â”œâ”€â”€ ðŸ“„ django_manager.py
â”‚       â”‚   â”œâ”€â”€ ðŸ“„ env_manager.py
â”‚       â”‚   â”œâ”€â”€ ðŸ“„ file_counter.py
â”‚       â”‚   â””â”€â”€ ðŸ“„ file_ops.py
â”‚       â”œâ”€â”€ ðŸ“„ __init__.py
â”‚       â”œâ”€â”€ ðŸ“„ __main__.py
â”‚       â”œâ”€â”€ ðŸ“„ cli.py
â”‚       â”œâ”€â”€ ðŸ“„ config.py
â”‚       â””â”€â”€ ðŸ“„ utils.py
â”œâ”€â”€ ðŸ“ tests
â”‚   â”œâ”€â”€ ðŸ“ test_tools
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ test_clean_pycache.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ test_django.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ test_env_manager.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ test_file_counter.py
â”‚   â”‚   â”œâ”€â”€ ðŸ“„ test_file_ops.py
â”‚   â”‚   â””â”€â”€ ðŸ“„ test_sample.py
â”‚   â”œâ”€â”€ ðŸ“„ __init__.py
â”‚   â”œâ”€â”€ ðŸ“„ conftest.py
â”‚   â””â”€â”€ ðŸ“„ test_cli.py
â”œâ”€â”€ ðŸ“„ pyproject.toml
â””â”€â”€ ðŸ“„ README.md


============================================================
ðŸ“ FILE CONTENTS:

============================================================
ðŸ“„ FILE: pyproject.toml
============================================================
[build-system]
requires = ["setuptools>=64", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "mytools"
version = "0.2.0"
description = "Modular CLI Tool Suite for Python developers"
readme = "README.md"
authors = [
    {name = "Your Name", email = "you@example.com"},
]
license = {text = "MIT"}
classifiers = [
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Environment :: Console",
    "Intended Audience :: Developers",
]
dependencies = [
    "typer[all]>=0.12",
    "pydantic>=2.5",
    "pydantic-settings>=2.1",
    "python-dotenv>=1.0",
    "rich>=13.7",          # beautiful console output
    "importlib-metadata; python_version<'3.8'",
    "pyperclip>=1.8",
]
requires-python = ">=3.9"

[project.scripts]
mytools = "mytools.cli:app"

[project.entry-points."mytools.plugins"]
clean-pycache = "mytools.tools.clean_pycache:CleanPycacheTool"
django = "mytools.tools.django_manager:DjangoTool"
env = "mytools.tools.env_manager:EnvTool"
file-ops = "mytools.tools.file_ops:FileOperationsTool"
file-counter = "mytools.tools.file_counter:FileCounterTool"
context = "mytools.tools.context_generator:FullContextTool"

[tool.setuptools.packages.find]
where = ["src"]
include = ["mytools*"]

[tool.pytest.ini_options]
minversion = "7.0"
addopts = "-ra -q --strict-markers"
testpaths = [
    "tests",
]

============================================================
ðŸ“„ FILE: src\mytools\cli.py
============================================================
# cli.py

"""Main CLI application using Typer."""
import typer
from typing import Optional
from importlib.metadata import entry_points
import sys

from .utils import setup_logging, logger
from .config import settings

app = typer.Typer(
    name="mytools",
    help="ðŸ› ï¸ MyTools â€“ Developer's Swiss Army Knife",
    add_completion=False,
    rich_markup_mode="rich",
)

# ----------------------------------------------------------------------
# Plugin: Dynamically load all tools from entry_points
# ----------------------------------------------------------------------
def load_plugins():
    """Load all tools registered under 'mytools.plugins' entry point."""
    plugins = {}
    eps = entry_points()
    # Python 3.10+ uses select(), older uses dict interface
    if hasattr(eps, "select"):
        group = eps.select(group="mytools.plugins")
    else:
        group = eps.get("mytools.plugins", [])
    for ep in group:
        try:
            tool_class = ep.load()
            plugins[ep.name] = tool_class
            logger.debug(f"Loaded plugin: {ep.name} -> {tool_class}")
        except Exception as e:
            logger.error(f"Failed to load plugin {ep.name}: {e}")
    return plugins

_plugins = load_plugins()

# ----------------------------------------------------------------------
# Register each plugin as a Typer subcommand
# ----------------------------------------------------------------------
for name, tool_class in _plugins.items():
    # Instantiate tool once (or you can lazy-load inside command)
    tool_instance = tool_class()

    # Create a Typer command that calls tool.run()
    def make_cmd(tool):
        def cmd(ctx: typer.Context):
            """Run the tool."""
            tool.run()
        return cmd

    app.command(name=name)(make_cmd(tool_instance))

# ----------------------------------------------------------------------
# Builtâ€‘in commands that don't need a plugin
# ----------------------------------------------------------------------
@app.command("list")
def list_tools():
    """ðŸ“‹ List all available tools."""
    typer.echo("ðŸ”§ Available tools:\n")
    for name in _plugins:
        typer.echo(f"  â€¢ {name}")
    typer.echo("\nUse `mytools <tool-name>` to run a tool.")

@app.command("info")
def info():
    """â„¹ï¸  Show system information."""
    typer.echo(f"MyTools version: {__import__('mytools').__version__}")
    typer.echo(f"Python: {sys.version}")
    typer.echo(f"Config file: {settings.config_file or 'default'}")

# ----------------------------------------------------------------------
# If no command given, show help
# ----------------------------------------------------------------------
def main():
    if len(sys.argv) == 1:
        typer.echo(app.get_help())
    else:
        app()

if __name__ == "__main__":
    main()

============================================================
ðŸ“„ FILE: src\mytools\config.py
============================================================
"""Configuration management with pydantic-settings."""
from pathlib import Path
from typing import Set, Optional, List
from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import Field, field_validator

class Settings(BaseSettings):
    """Application settings loaded from environment and .env file."""

    model_config = SettingsConfigDict(
        env_prefix="MYTOOLS_",
        env_file=".env",
        env_file_encoding="utf-8",
        extra="ignore",
    )

    # Ignore directories (defaults + user additions)
    ignore_dirs: Set[str] = Field(
        default_factory=lambda: {
            ".git", ".venv", "venv", "env", "__pycache__",
            ".idea", ".vscode", "node_modules", "dist", "build",
            "migrations", "logs", ".pytest_cache", ".mypy_cache",
        }
    )

    # Ignore file patterns (supports wildcards via fnmatch)
    ignore_files: Set[str] = Field(
        default_factory=lambda: {
            ".DS_Store", "Thumbs.db", "*.pyc", "*.pyo", "*.pyd",
            "*.log", "*.tmp", ".env", ".env.*", "*.db", "*.sqlite3",
        }
    )

    # Maximum file size to read when generating context (in bytes)
    max_file_size: int = 100_000  # 100 KB

    # Maximum total size of context output (in bytes)
    max_total_size: int = 500_000  # 500 KB

    # Log level (DEBUG, INFO, WARNING, ERROR)
    log_level: str = "INFO"

    # Optional path to user config file (TOML/YAML)
    config_file: Optional[Path] = None

    @field_validator("log_level")
    @classmethod
    def validate_log_level(cls, v: str) -> str:
        v = v.upper()
        if v not in {"DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"}:
            return "INFO"
        return v

# Global settings instance
settings = Settings()

# Allow runtime updates (e.g., adding ignore dirs)
def add_ignore_dir(directory: str) -> None:
    settings.ignore_dirs.add(directory)

def add_ignore_file(pattern: str) -> None:
    settings.ignore_files.add(pattern)

============================================================
ðŸ“„ FILE: src\mytools\utils.py
============================================================
"""Utility functions and logging setup."""
import os
import sys
import logging
from pathlib import Path
from typing import Union
from rich.console import Console
from rich.logging import RichHandler
from .config import settings

console = Console()

def setup_logging():
    """Configure logging with Rich handler."""
    logging.basicConfig(
        level=settings.log_level,
        format="%(message)s",
        datefmt="[%X]",
        handlers=[RichHandler(rich_tracebacks=True, markup=True)],
    )
    return logging.getLogger("mytools")

logger = setup_logging()

def format_size(size_bytes: int) -> str:
    """Convert bytes to human-readable string."""
    for unit in ["B", "KB", "MB", "GB"]:
        if size_bytes < 1024.0:
            return f"{size_bytes:.2f} {unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.2f} TB"

def clear_screen():
    """Cross-platform clear console."""
    os.system("cls" if os.name == "nt" else "clear")

def get_project_path() -> Path:
    """Get current working directory as project path."""
    return Path.cwd()

def ensure_directory(path: Union[str, Path]) -> Path:
    """Create directory if it doesn't exist."""
    p = Path(path)
    p.mkdir(parents=True, exist_ok=True)
    return p

def read_file_safe(file_path: Union[str, Path], max_size: int = None) -> str:
    """Safely read text file with size limit."""
    path = Path(file_path)
    if max_size is None:
        max_size = settings.max_file_size
    try:
        if path.stat().st_size > max_size:
            logger.warning(f"Skipping {path.name}: size exceeds limit")
            return ""
        return path.read_text(encoding="utf-8")
    except (OSError, UnicodeDecodeError, PermissionError) as e:
        logger.debug(f"Cannot read {path}: {e}")
        return ""

def should_ignore(path: Path, ignore_dirs: set, ignore_files: set) -> bool:
    """Check if a file/directory should be ignored."""
    name = path.name
    if path.is_dir():
        return name in ignore_dirs or name.startswith(".")
    else:
        # Check exact name or pattern (simple wildcard support)
        if name in ignore_files:
            return True
        for pattern in ignore_files:
            if pattern.startswith("*") and name.endswith(pattern[1:]):
                return True
            if pattern.endswith("*") and name.startswith(pattern[:-1]):
                return True
        return False

============================================================
ðŸ“„ FILE: src\mytools\__init__.py
============================================================
"""MyTools - Modular CLI Tool Suite."""
__version__ = "0.2.0"

============================================================
ðŸ“„ FILE: src\mytools\__main__.py
============================================================
"""Allow running with `python -m mytools`."""
from .cli import app

if __name__ == "__main__":
    app()

============================================================
ðŸ“„ FILE: src\mytools\tools\base.py
============================================================
"""Abstract base class for tools."""
from abc import ABC, abstractmethod

class BaseTool(ABC):
    """All tools must inherit from this class."""

    name: str = "Unnamed Tool"
    description: str = "No description"

    @abstractmethod
    def run(self) -> None:
        """Execute the tool's main functionality."""
        pass

============================================================
ðŸ“„ FILE: src\mytools\tools\clean_pycache.py
============================================================
"""Tool to clean __pycache__ directories."""
import os
import shutil
from pathlib import Path

from rich.progress import track
from rich.console import Console

from ..utils import logger, format_size, get_project_path
from .base import BaseTool

class CleanPycacheTool(BaseTool):
    name = "ðŸ§¹ Clean __pycache__"
    description = "Remove all __pycache__ folders recursively"

    def run(self) -> None:
        # from ..cli import console  # lazy import to avoid circular
        console = Console()

        console.clear()
        console.rule("[bold blue]CLEAN PYTHON CACHE[/]")

        start_path = get_project_path()
        console.print(f"ðŸ” Cleaning in: [cyan]{start_path}[/]")

        if not console.input("\nâš ï¸  [yellow]Delete all __pycache__ folders?[/] (y/n): ").lower() == "y":
            console.print("[red]âŒ Operation cancelled.[/]")
            return

        deleted = 0
        total_size = 0

        # Use os.walk, but we can also use Path.rglob
        for root, dirs, _ in os.walk(start_path):
            if "__pycache__" in dirs:
                path = Path(root) / "__pycache__"
                try:
                    folder_size = self._folder_size(path)
                    shutil.rmtree(path, ignore_errors=True)
                    dirs.remove("__pycache__")
                    deleted += 1
                    total_size += folder_size
                    rel_path = path.relative_to(start_path)
                    console.print(f"âœ… Deleted: [dim]{rel_path}[/] [green]({format_size(folder_size)})[/]")
                except Exception as e:
                    logger.error(f"Failed to delete {path}: {e}")

        if deleted:
            console.print("\n[bold green]ðŸŽ¯ Summary:[/]")
            console.print(f"   â€¢ Folders deleted: {deleted}")
            console.print(f"   â€¢ Space freed: {format_size(total_size)}")
        else:
            console.print("\n[blue]â„¹ï¸  No __pycache__ folders found.[/]")

        console.input("\nPress Enter to continue...")

    @staticmethod
    def _folder_size(path: Path) -> int:
        return sum(f.stat().st_size for f in path.rglob("*") if f.is_file())

============================================================
ðŸ“„ FILE: src\mytools\tools\context_generator.py
============================================================
"""Tool to generate optimized project context for AI assistance."""

import os
import fnmatch
from pathlib import Path
from typing import List, Set, Optional
from datetime import datetime

from rich.console import Console
from rich.prompt import Prompt, Confirm
from rich.panel import Panel
from rich.table import Table

from .base import BaseTool
from ..utils import logger, get_project_path, format_size

class FullContextTool(BaseTool):
    """Create optimized project context for AI assistance with flexible filtering."""

    name = "ðŸ“„ Generate AI Context"
    description = "Create optimized project context with filtering options for AI"

    # Default ignore settings
    DEFAULT_IGNORE_DIRS = {
        ".git", ".github", ".gitlab",
        ".venv", "venv", "env", "virtualenv",
        "__pycache__", ".pytest_cache", ".mypy_cache",
        ".idea", ".vscode", ".vs",
        "node_modules", "bower_components",
        "dist", "build", "out", "target",
        "instance", ".extra", "migrations", "logs",
        "static/images", "media",
        "coverage", ".coverage",
        "site-packages", ".eggs", "eggs",
    }

    DEFAULT_IGNORE_FILES = {
        ".DS_Store", "Thumbs.db", "desktop.ini",
        "package-lock.json", "yarn.lock", "pnpm-lock.yaml",
        "full_project_context.txt", "ai_context.txt",
        "generate_context.py",
        "db.sqlite3", "database.db", "*.db",
        ".env", ".env.local", ".env.*",
        ".antigravityignore", ".gitignore",
        "requirements.txt", "requirements-dev.txt",
        "poetry.lock", "Pipfile.lock",
        "*.pyc", "*.pyo", "*.pyd",
        "*.so", "*.dll", "*.dylib",
        "*.log", "*.tmp", "*.temp",
        "*.cache", "*.swp", "*.swo",
    }

    # Prioritized extensions for AI understanding
    PRIORITY_EXTENSIONS = {
        ".py", ".js", ".jsx", ".ts", ".tsx",  # Code
        ".html", ".htm", ".css", ".scss", ".sass",  # Web
        ".json", ".yaml", ".yml", ".toml",  # Config
        ".md", ".txt", ".rst",  # Documentation
        ".sql", ".graphql", ".gql",  # Database
        ".java", ".cpp", ".c", ".h", ".hpp",  # Other languages
        ".go", ".rs", ".rb", ".php",
        ".cs", ".swift", ".kt", ".dart",
    }

    def run(self) -> None:
        """Execute the context generation process with user options."""
        console = Console()
        console.clear()
        console.rule("[bold magenta]ðŸ¤– AI-PROJECT CONTEXT GENERATOR[/]")
        
        project_path = get_project_path()
        project_name = os.path.basename(project_path)
        
        info_panel = (
            f"ðŸ“ [bold cyan]Project:[/] {project_name}\n"
            f"ðŸ“ [bold cyan]Location:[/] [dim]{project_path}[/]"
        )
        console.print(Panel(info_panel, border_style="cyan", expand=False))
        
        # User configuration
        config = self._get_user_config(console)
        
        # Generation Process
        with console.status("[magenta]ðŸ” Scanning project and generating context...[/]", spinner="dots"):
            tree_structure = self._generate_tree(project_path, config['ignore_dirs'])
            
            if config['selection_mode'] == 'custom':
                # Pause spinner for custom input
                console.print("\n")
                file_contents = self._get_custom_files_content(console, project_path, config)
            elif config['selection_mode'] == 'all':
                file_contents = self._get_all_files_content(project_path, config)
            else:  # smart
                file_contents = self._get_smart_files_content(project_path, config)
            
            final_output = self._format_output(project_name, tree_structure, file_contents, config)
        
        # Preview and Save
        self._show_preview(console, final_output)
        self._handle_save_options(console, project_name, final_output)
        
        console.input("\n[dim]Press Enter to continue...[/]")
    
    def _get_user_config(self, console: Console) -> dict:
        console.print("\n[bold]âš™ï¸  Configuration Options:[/]")
        
        # Selection mode
        console.print("\n[bold cyan]1. File Selection Mode[/]")
        mode_text = (
            "[1] ðŸ§  Smart (recommended) - Key files only\n"
            "[2] ðŸ“š All - All readable files\n"
            "[3] ðŸŽ¯ Custom - Select specific files/folders"
        )
        console.print(Panel(mode_text, expand=False))
        mode_choice = Prompt.ask("Choose mode", choices=["1", "2", "3"], default="1")
        mode_map = {'1': 'smart', '2': 'all', '3': 'custom'}
        
        # Ignore Directories
        console.print("\n[bold cyan]2. Ignore Directories[/]")
        default_dirs_preview = ", ".join(sorted(list(self.DEFAULT_IGNORE_DIRS))[:5]) + "..."
        console.print(f"[dim]Default ignores:[/] {default_dirs_preview}")
        custom_ignore = Prompt.ask("Add more dirs to ignore (comma separated, leave empty to skip)", default="")
        
        ignore_dirs = set(self.DEFAULT_IGNORE_DIRS)
        if custom_ignore:
            ignore_dirs.update([d.strip() for d in custom_ignore.split(',') if d.strip()])
        
        # Ignore Files
        console.print("\n[bold cyan]3. Ignore File Patterns[/]")
        console.print("[dim]Default includes: *.log, *.tmp, .env*, etc.[/]")
        custom_files = Prompt.ask("Add more file patterns (comma separated, leave empty to skip)", default="")
        
        ignore_files = set(self.DEFAULT_IGNORE_FILES)
        if custom_files:
            ignore_files.update([f.strip() for f in custom_files.split(',') if f.strip()])
        
        return {
            'ignore_dirs': ignore_dirs,
            'ignore_files': ignore_files,
            'selection_mode': mode_map[mode_choice],
            'max_file_size': 20000,   # 20KB limit per file
            'max_total_size': 200000  # 200KB total limit
        }
    
    def _generate_tree(self, start_path: str, ignore_dirs: Set[str]) -> str:
        """Generate plain text tree structure (No rich tags for AI export)."""
        def _tree_recursive(path: Path, prefix: str = "", depth: int = 0, max_depth: int = 5) -> str:
            if depth > max_depth:
                return prefix + "â””â”€â”€ [depth limit reached]\n"
            try:
                items = sorted(path.iterdir())
            except (PermissionError, OSError):
                return ""
            
            dirs = [i for i in items if i.is_dir() and not i.name.startswith('.') and i.name not in ignore_dirs]
            files = [i for i in items if i.is_file() and not i.name.startswith('.')]
            all_items = dirs + files
            
            tree_str = ""
            for idx, item in enumerate(all_items):
                is_last = idx == len(all_items) - 1
                connector = "â””â”€â”€ " if is_last else "â”œâ”€â”€ "
                icon = "ðŸ“ " if item.is_dir() else "ðŸ“„ "
                tree_str += f"{prefix}{connector}{icon}{item.name}\n"
                
                if item.is_dir():
                    extension = "    " if is_last else "â”‚   "
                    tree_str += _tree_recursive(item, prefix + extension, depth + 1, max_depth)
            return tree_str
            
        return f"Project Tree:\n{_tree_recursive(Path(start_path))}"
    
    def _get_smart_files_content(self, project_path: str, config: dict) -> str:
        important_patterns = [
            "README*", "readme*", "requirements*.txt", "pyproject.toml", "package.json",
            "setup.py", "setup.cfg", "*.py", "*.js", "*.ts", "*.jsx", "*.tsx",
            "*.html", "*.css", "*.json", "*.yaml", "*.yml",
        ]
        
        content_str, total_size = "", 0
        for root, dirs, files in os.walk(project_path):
            dirs[:] = [d for d in dirs if d not in config['ignore_dirs']]
            for file in files:
                if self._should_ignore_file(file, config['ignore_files']): continue
                if not self._is_important_file(file, important_patterns): continue
                
                path = os.path.join(root, file)
                content = self._read_file_safe(path, config['max_file_size'])
                if content:
                    rel_path = os.path.relpath(path, project_path)
                    total_size += len(content)
                    if total_size > config['max_total_size']:
                        return content_str + "\n\n[âš ï¸  Total size limit reached. Some files omitted.]\n"
                    content_str += self._format_file_content(rel_path, content)
        return content_str
    
    def _get_all_files_content(self, project_path: str, config: dict) -> str:
        content_str, total_size = "", 0
        for root, dirs, files in os.walk(project_path):
            dirs[:] = [d for d in dirs if d not in config['ignore_dirs']]
            for file in files:
                if self._should_ignore_file(file, config['ignore_files']): continue
                
                path = os.path.join(root, file)
                content = self._read_file_safe(path, config['max_file_size'])
                if content:
                    rel_path = os.path.relpath(path, project_path)
                    total_size += len(content)
                    if total_size > config['max_total_size']:
                        return content_str + "\n\n[âš ï¸  Total size limit reached. Some files omitted.]\n"
                    content_str += self._format_file_content(rel_path, content)
        return content_str
    
    def _get_custom_files_content(self, console: Console, project_path: str, config: dict) -> str:
        console.rule("[bold yellow]ðŸŽ¯ Custom File Selection[/]")
        console.print("Enter file/folder paths (relative to project). Type [bold green]'done'[/] when finished, or [bold blue]'tree'[/] to see structure.")
        
        selected_paths = []
        while True:
            user_input = Prompt.ask("\nEnter path").strip()
            
            if user_input.lower() == 'done': break
            elif user_input.lower() == 'tree':
                console.print("\n[dim]Current tree (first 2 levels):[/]")
                self._show_quick_tree(console, project_path, 2)
                continue
            
            if user_input:
                full_path = os.path.join(project_path, user_input)
                if os.path.exists(full_path):
                    selected_paths.append(full_path)
                    console.print(f"âœ… [green]Added:[/] {user_input}")
                else:
                    console.print(f"âŒ [red]Not found:[/] {user_input}")
        
        if not selected_paths:
            console.print("[yellow]No files selected. Falling back to Smart Selection.[/]")
            return self._get_smart_files_content(project_path, config)
            
        content_str, total_size = "", 0
        for selected_path in selected_paths:
            if os.path.isfile(selected_path):
                content = self._read_file_safe(selected_path, config['max_file_size'])
                if content:
                    rel_path = os.path.relpath(selected_path, project_path)
                    total_size += len(content)
                    content_str += self._format_file_content(rel_path, content)
            elif os.path.isdir(selected_path):
                for root, dirs, files in os.walk(selected_path):
                    dirs[:] = [d for d in dirs if d not in config['ignore_dirs']]
                    for file in files:
                        if self._should_ignore_file(file, config['ignore_files']): continue
                        path = os.path.join(root, file)
                        content = self._read_file_safe(path, config['max_file_size'])
                        if content:
                            rel_path = os.path.relpath(path, project_path)
                            total_size += len(content)
                            content_str += self._format_file_content(rel_path, content)
                            
            if total_size > config['max_total_size']:
                content_str += "\n\n[âš ï¸  Total size limit reached.]\n"
                break
                
        return content_str
    
    def _should_ignore_file(self, filename: str, ignore_patterns: Set[str]) -> bool:
        for pattern in ignore_patterns:
            if fnmatch.fnmatch(filename, pattern):
                return True
        return False
    
    def _is_important_file(self, filename: str, patterns: List[str]) -> bool:
        for pattern in patterns:
            if fnmatch.fnmatch(filename, pattern):
                return True
        ext = os.path.splitext(filename)[1].lower()
        return ext in self.PRIORITY_EXTENSIONS
    
    def _read_file_safe(self, filepath: str, max_size: int) -> Optional[str]:
        try:
            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read(max_size * 2)
                if len(content) > max_size:
                    content = content[:max_size] + "\n\n...[File truncated due to size limit]..."
                return content if content.strip() else None
        except Exception as e:
            return f"[Error reading file: {e}]"
    
    def _format_file_content(self, rel_path: str, content: str) -> str:
        separator = "=" * 60
        return f"\n{separator}\nðŸ“„ FILE: {rel_path}\n{separator}\n{content}\n"
    
    def _format_output(self, project_name: str, tree: str, contents: str, config: dict) -> str:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        return f"""ðŸ¤– PROJECT CONTEXT FOR AI ASSISTANCE
{'=' * 60}
PROJECT: {project_name}
SELECTION MODE: {config['selection_mode'].upper()}
GENERATED: {timestamp}
{'=' * 60}

ðŸ“ PROJECT STRUCTURE:
{tree}

{'=' * 60}
ðŸ“ FILE CONTENTS:
{contents}

{'=' * 60}
ðŸ’¡ FOR AI ASSISTANT:
This is the complete context of the project. Please analyze the structure
and code to provide accurate assistance. Key files include configuration
files, source code, and documentation.

When responding, reference specific files and paths from the structure above.
"""
    
    def _show_preview(self, console: Console, output: str) -> None:
        console.rule("[bold cyan]ðŸ“‹ CONTEXT PREVIEW[/]")
        lines = output.split('\n')
        preview_text = '\n'.join(lines[:30])
        
        if len(lines) > 30:
            preview_text += f"\n\n[dim]... (Showing first 30 of {len(lines)} lines) ...[/]"
            
        console.print(Panel(preview_text, border_style="cyan", title="Preview Output"))
        
        table = Table(show_header=False, box=None)
        table.add_row("Total lines:", str(len(lines)))
        table.add_row("Approx. size:", format_size(len(output.encode('utf-8'))))
        console.print(Panel(table, title="ðŸ“Š Statistics", expand=False))
    
    def _show_quick_tree(self, console: Console, path: str, depth: int = 2) -> None:
        def _quick_tree(p: Path, current_depth: int, max_depth: int):
            if current_depth > max_depth: return
            prefix = "  " * current_depth
            try:
                for item in sorted(p.iterdir()):
                    if item.name.startswith('.'): continue
                    icon = "ðŸ“" if item.is_dir() else "ðŸ“„"
                    console.print(f"{prefix}{icon} {item.name}")
                    if item.is_dir():
                        _quick_tree(item, current_depth + 1, max_depth)
            except: pass
        _quick_tree(Path(path), 0, depth)
    
    def _handle_save_options(self, console: Console, project_name: str, content: str) -> None:
        console.print("\n[bold]ðŸ’¾ Save Options:[/]")
        options = (
            "[1] Save full context\n"
            "[2] Save only specific section\n"
            "[3] Save as AI prompt template\n"
            "[4] Don't save (Exit)"
        )
        console.print(Panel(options, expand=False))
        
        choice = Prompt.ask("Choose option", choices=["1", "2", "3", "4"], default="1")
        if choice == '4': return
        
        default_filename = f"{project_name}_context.txt"
        filename = Prompt.ask("Enter filename", default=default_filename)
        
        if choice == '1':
            save_content = content
        elif choice == '2':
            section = Prompt.ask("Save [1] Structure only or [2] Contents only?", choices=["1", "2"], default="1")
            lines = content.split('\n')
            if section == '1':
                start = next(i for i, line in enumerate(lines) if "PROJECT STRUCTURE:" in line)
                end = next((i for i, line in enumerate(lines[start+1:]) if "="*60 in line), len(lines))
                save_content = '\n'.join(lines[start:start+end+1])
            else:
                start = next(i for i, line in enumerate(lines) if "FILE CONTENTS:" in line)
                save_content = '\n'.join(lines[start:])
        else:
            save_content = self._create_ai_prompt_template(content)
        
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(save_content)
            
            console.print(f"\nâœ… [bold green]Saved successfully to:[/] {os.path.abspath(filename)}")
            
            if choice == '3':
                console.print("\n[bold magenta]ðŸ¤– AI Prompt Suggestion:[/]")
                prompt_preview = save_content[:300] + "...\n[dim][Full prompt saved in file][/]"
                console.print(Panel(prompt_preview, border_style="magenta"))
                
        except Exception as e:
            console.print(f"[red]âŒ Error saving file: {e}[/]")
    
    def _create_ai_prompt_template(self, context: str) -> str:
        return f"""You are an expert developer assistant. Below is the complete context of a project. Please analyze it thoroughly and provide accurate assistance.

PROJECT CONTEXT:
{context}

YOUR TASK:
Based on the project structure and code above, please:
1. Understand the project architecture and main components.
2. Identify key files, dependencies, and configuration.
3. Provide specific, actionable advice or code.

My specific request is: [DESCRIBE WHAT YOU NEED HELP WITH HERE]

Please reference specific files and paths from the project structure in your response. Be detailed but concise."""
    

============================================================
ðŸ“„ FILE: src\mytools\tools\django_manager.py
============================================================
"""Django project management tool."""
from .base import BaseTool
from ..utils import console, logger

class DjangoTool(BaseTool):
    name = "ðŸš€ Django Manager"
    description = "Create and manage Django projects"

    def run(self) -> None:
        console.clear()
        console.rule("[bold green]DJANGO MANAGER[/]")
        console.print("\n[yellow]âš ï¸  This tool is under construction![/]")
        console.print("\nComing soon: Django project creation, app management, migrations, etc.")
        console.input("\nPress Enter to continue...")

============================================================
ðŸ“„ FILE: src\mytools\tools\env_manager.py
============================================================
"""Virtual environment and .env file manager."""

import os
import shutil
import sys
from pathlib import Path
from typing import Optional, Tuple, List
import subprocess

from .base import BaseTool
from ..utils import console, logger


class EnvTool(BaseTool):
    """Manage virtual environments and environment files."""

    name = "ðŸ Environment Manager"
    description = "Create/delete virtual env, manage .env files"

    def run(self) -> None:
        """Display environment management menu."""
        while True:
            console.clear()
            console.rule("[bold yellow]ENVIRONMENT MANAGER[/]")
            
            console.print("\n[bold cyan]1.[/] Create Virtual Environment (.venv)")
            console.print("[bold cyan]2.[/] Delete Virtual Environment")
            console.print("[bold cyan]3.[/] Create .env File")
            console.print("[bold cyan]4.[/] Delete .env File")
            console.print("[bold cyan]5.[/] List Environment Variables")
            console.print("[bold cyan]6.[/] Check Python Environment")
            console.print("[bold cyan]7.[/] Back to Main Menu")
            
            choice = console.input("\n[bold]Select option (1-7): [/]").strip()

            if choice == "1":
                self._create_venv()
            elif choice == "2":
                self._delete_venv()
            elif choice == "3":
                self._create_env_file()
            elif choice == "4":
                self._delete_env_file()
            elif choice == "5":
                self._list_env_vars()
            elif choice == "6":
                self._check_python_env()
            elif choice == "7":
                break
            else:
                console.print("[red]âŒ Invalid option[/]")

            if choice != "7":
                console.input("\n[dim]Press Enter to continue...[/]")

    def _create_venv(self) -> None:
        """Create a virtual environment."""
        console.clear()
        console.rule("[bold cyan]CREATE VIRTUAL ENVIRONMENT[/]")

        current_dir = Path.cwd()
        console.print(f"[blue]ðŸ“‚[/] Current directory: [cyan]{current_dir}[/]")

        console.print("\n[bold]ðŸ”§ Virtual Environment Options:[/]")
        console.print("   [cyan]1.[/] .venv [dim](Recommended)[/]")
        console.print("   [cyan]2.[/] venv")
        console.print("   [cyan]3.[/] Custom name")

        choice = console.input("\n[bold]Select option (1-3): [/]").strip()

        if choice == "1":
            venv_name = ".venv"
        elif choice == "2":
            venv_name = "venv"
        elif choice == "3":
            venv_name = console.input("[bold]Enter virtual environment name: [/]").strip()
            if not venv_name:
                console.print("[red]âŒ Name cannot be empty.[/]")
                return
        else:
            console.print("[red]âŒ Invalid option.[/]")
            return

        venv_path = current_dir / venv_name

        # Check if already exists
        if venv_path.exists():
            console.print(f"[yellow]âš ï¸  Virtual environment '{venv_name}' already exists.[/]")
            overwrite = console.input("[bold]Delete and recreate? (y/n): [/]").lower()
            if overwrite != 'y':
                console.print("[red]âŒ Operation cancelled.[/]")
                return
            shutil.rmtree(venv_path, ignore_errors=True)
            console.print(f"[green]âœ… Existing '{venv_name}' deleted.[/]")

        console.print(f"\n[bold]ðŸš€ Creating virtual environment '{venv_name}'...[/]")

        # Use sys.executable to ensure using current Python
        success, output = self._run_command([sys.executable, "-m", "venv", str(venv_name)])

        if success:
            console.print(f"[green]âœ… Virtual environment created at: {venv_path}[/]")
            
            # Show activation commands
            console.print("\n[bold]ðŸ”§ Activation commands:[/]")
            if os.name == 'nt':  # Windows
                console.print(f"   [cyan]{venv_name}\\Scripts\\activate[/]")
            else:  # Unix/Linux/Mac
                console.print(f"   [cyan]source {venv_name}/bin/activate[/]")
            
            # Offer to install requirements if exists
            req_file = current_dir / "requirements.txt"
            if req_file.exists():
                install_req = console.input(f"\n[bold]ðŸ“¦ Install from requirements.txt? (y/n): [/]").lower()
                if install_req == 'y':
                    self._install_requirements(venv_path, req_file)
        else:
            console.print(f"[red]âŒ Failed to create virtual environment: {output}[/]")
            logger.error(f"Venv creation failed: {output}")

    def _delete_venv(self) -> None:
        """Delete a virtual environment."""
        console.clear()
        console.rule("[bold cyan]DELETE VIRTUAL ENVIRONMENT[/]")

        current_dir = Path.cwd()
        console.print(f"[blue]ðŸ“‚[/] Current directory: [cyan]{current_dir}[/]")

        # Look for common venv names
        common_venvs = ['.venv', 'venv', 'env']
        found_venvs = []

        for venv_name in common_venvs:
            venv_path = current_dir / venv_name
            if venv_path.exists():
                found_venvs.append((venv_name, venv_path))

        if not found_venvs:
            console.print("\n[yellow]â„¹ï¸  No standard virtual environments found in current directory.[/]")
            custom_name = console.input("[bold]Enter virtual environment name to delete: [/]").strip()
            if custom_name:
                custom_path = current_dir / custom_name
                if custom_path.exists():
                    found_venvs.append((custom_name, custom_path))
                else:
                    console.print(f"[red]âŒ Virtual environment '{custom_name}' not found.[/]")
                    return
            else:
                console.print("[red]âŒ No virtual environment specified.[/]")
                return

        console.print("\n[bold]ðŸ“ Found virtual environments:[/]")
        for i, (name, path) in enumerate(found_venvs, 1):
            size = self._get_folder_size(path)
            console.print(f"   [cyan]{i}.[/] {name} ([dim]{self._format_size(size)}[/])")

        if len(found_venvs) > 1:
            choice = console.input(f"\n[bold]Select environment to delete (1-{len(found_venvs)}): [/]").strip()
            if choice.isdigit():
                idx = int(choice) - 1
                if 0 <= idx < len(found_venvs):
                    venv_name, venv_path = found_venvs[idx]
                else:
                    console.print("[red]âŒ Invalid selection.[/]")
                    return
            else:
                console.print("[red]âŒ Invalid input.[/]")
                return
        else:
            venv_name, venv_path = found_venvs[0]

        console.print(f"\n[yellow]âš ï¸  WARNING:[/] This will permanently delete '[cyan]{venv_name}[/]'")
        console.print(f"[dim]ðŸ“ Path: {venv_path}[/]")

        confirm = console.input(f"\n[bold]Are you sure you want to delete '{venv_name}'? (y/N): [/]").lower()
        if confirm != 'y':
            console.print("[red]âŒ Operation cancelled.[/]")
            return

        try:
            shutil.rmtree(venv_path, ignore_errors=True)
            console.print(f"[green]âœ… Virtual environment '{venv_name}' deleted successfully.[/]")
            logger.info(f"Deleted virtual environment: {venv_name}")
        except Exception as e:
            console.print(f"[red]âŒ Failed to delete: {e}[/]")
            logger.error(f"Failed to delete venv: {e}")

    def _create_env_file(self) -> None:
        """Create a .env file with template."""
        console.clear()
        console.rule("[bold cyan]CREATE .ENV FILE[/]")

        current_dir = Path.cwd()
        env_path = current_dir / ".env"

        if env_path.exists():
            console.print("[yellow]âš ï¸  .env file already exists.[/]")
            overwrite = console.input("[bold]Overwrite? (y/n): [/]").lower()
            if overwrite != 'y':
                console.print("[red]âŒ Operation cancelled.[/]")
                return

        console.print("\n[bold]ðŸ“ Creating .env file with common environment variables...[/]")
        console.print("[dim]   (You can edit these values after creation)[/]")

        env_template = """# Environment Variables
# Add your sensitive data here - never commit to version control

# Database Configuration
DB_NAME=your_database_name
DB_USER=your_username
DB_PASSWORD=your_password
DB_HOST=localhost
DB_PORT=5432

# Django Settings
DJANGO_SECRET_KEY=your-secret-key-here-change-this-in-production
DJANGO_DEBUG=True
DJANGO_ALLOWED_HOSTS=localhost,127.0.0.1

# Email Configuration
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USE_TLS=True
EMAIL_HOST_USER=your-email@gmail.com
EMAIL_HOST_PASSWORD=your-app-specific-password

# API Keys
API_KEY=your_api_key_here
SECRET_API_KEY=your_secret_api_key_here

# Application Settings
LOG_LEVEL=INFO
ENVIRONMENT=development
"""
        try:
            with open(env_path, 'w', encoding='utf-8') as f:
                f.write(env_template)
            
            console.print(f"[green]âœ… .env file created at: {env_path}[/]")
            console.print(f"[dim]ðŸ“ File size: {env_path.stat().st_size} bytes[/]")
            
            # Show security warning
            console.print("\n[yellow]âš ï¸  SECURITY REMINDER:[/]")
            console.print("   â€¢ Add .env to .gitignore")
            console.print("   â€¢ Never commit .env to version control")
            console.print("   â€¢ Use different .env files for different environments")
            
            # Show preview
            preview = console.input("\n[bold]Show file preview? (y/n): [/]").lower()
            if preview == 'y':
                console.print("\n[bold]ðŸ“„ .env Preview:[/]")
                console.rule("-" * 40)
                with open(env_path, 'r', encoding='utf-8') as f:
                    console.print(f.read())
                console.rule("-" * 40)
                
            logger.info(f"Created .env file in {current_dir}")
                
        except Exception as e:
            console.print(f"[red]âŒ Failed to create .env file: {e}[/]")
            logger.error(f"Failed to create .env: {e}")

    def _delete_env_file(self) -> None:
        """Delete .env file."""
        console.clear()
        console.rule("[bold cyan]DELETE .ENV FILE[/]")

        current_dir = Path.cwd()
        env_path = current_dir / ".env"

        if not env_path.exists():
            console.print("[red]âŒ .env file not found in current directory.[/]")
            return

        file_size = env_path.stat().st_size
        console.print(f"[blue]ðŸ“„[/] File: [cyan]{env_path}[/]")
        console.print(f"[dim]ðŸ“ Size: {self._format_size(file_size)}[/]")
        
        # Show preview
        preview = console.input("\n[bold]Show file preview? (y/n): [/]").lower()
        if preview == 'y':
            try:
                with open(env_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    console.print("\n[bold]ðŸ“„ File Content:[/]")
                    console.rule("-" * 40)
                    console.print(content[:500])  # Show first 500 chars
                    if len(content) > 500:
                        console.print("[dim]... (truncated)[/]")
                    console.rule("-" * 40)
            except Exception:
                console.print("[yellow]âš ï¸  Could not read file content.[/]")

        confirm = console.input(f"\n[yellow]âš ï¸  Delete .env file? (y/N): [/]").lower()
        if confirm != 'y':
            console.print("[red]âŒ Operation cancelled.[/]")
            return

        try:
            env_path.unlink()
            console.print("[green]âœ… .env file deleted successfully.[/]")
            logger.info(f"Deleted .env file in {current_dir}")
        except Exception as e:
            console.print(f"[red]âŒ Failed to delete: {e}[/]")
            logger.error(f"Failed to delete .env: {e}")

    def _list_env_vars(self) -> None:
        """List environment variables."""
        console.clear()
        console.rule("[bold cyan]ENVIRONMENT VARIABLES[/]")

        console.print("[bold]ðŸŒ System Environment Variables:[/]")
        console.rule("-" * 50)
        
        # Common environment variables to show
        common_vars = [
            'PATH', 'PYTHONPATH', 'VIRTUAL_ENV', 'HOME', 'USER',
            'LANG', 'PYTHON_VERSION', 'PWD', 'SHELL'
        ]
        
        env_vars = dict(os.environ)
        
        console.print("\n[bold]ðŸ”§ Common Variables:[/]")
        for var in common_vars:
            if var in env_vars:
                value = env_vars[var]
                # Truncate long values
                if len(value) > 100:
                    value = value[:100] + "..."
                console.print(f"   [cyan]{var}:[/] {value}")
        
        console.print("\n[bold]ðŸ“Š All Variables (alphabetical):[/]")
        console.rule("-" * 50)
        
        for key in sorted(env_vars.keys()):
            if key not in common_vars:  # Already shown
                value = env_vars[key]
                if len(value) > 50:
                    value = value[:50] + "..."
                console.print(f"   [cyan]{key}:[/] {value}")
        
        console.print(f"\n[bold]ðŸ“ˆ Total variables:[/] {len(env_vars)}")

    def _check_python_env(self) -> None:
        """Check current Python environment."""
        console.clear()
        console.rule("[bold cyan]PYTHON ENVIRONMENT CHECK[/]")

        console.print("[bold]ðŸ Python Information:[/]")
        console.print(f"   [cyan]Version:[/] {sys.version}")
        console.print(f"   [cyan]Executable:[/] {sys.executable}")
        console.print(f"   [cyan]Platform:[/] {sys.platform}")
        console.print(f"   [cyan]Prefix:[/] {sys.prefix}")

        # Check if in virtual environment
        if hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix):
            console.print("   [green]âœ… Running in virtual environment[/]")
            if 'VIRTUAL_ENV' in os.environ:
                console.print(f"   [cyan]Virtual env path:[/] {os.environ['VIRTUAL_ENV']}")
        else:
            console.print("   [yellow]â„¹ï¸  Running in system Python[/]")

        # Check pip version
        console.print("\n[bold]ðŸ“¦ Package Manager:[/]")
        success, output = self._run_command([sys.executable, "-m", "pip", "--version"])
        if success:
            pip_info = output.split('\n')[0] if output else "Unknown"
            console.print(f"   {pip_info}")
        else:
            console.print("   [red]âŒ pip not available[/]")

        # List installed packages (top 10)
        console.print("\n[bold]ðŸ“‹ Top installed packages:[/]")
        success, output = self._run_command([sys.executable, "-m", "pip", "list", "--format=freeze"])
        if success and output:
            packages = output.strip().split('\n')
            for pkg in packages[:10]:  # Show first 10
                console.print(f"   â€¢ {pkg}")
            if len(packages) > 10:
                console.print(f"   [dim]... and {len(packages) - 10} more[/]")
        else:
            console.print("   [yellow]â„¹ï¸  No packages found or pip error[/]")

    def _install_requirements(self, venv_path: Path, req_file: Path) -> None:
        """Install requirements in virtual environment.
        
        Args:
            venv_path: Path to virtual environment.
            req_file: Path to requirements.txt.
        """
        console.print(f"\n[bold]ðŸ“¦ Installing packages from {req_file}...[/]")
        
        # Determine pip path based on OS
        if os.name == 'nt':  # Windows
            pip_path = venv_path / "Scripts" / "pip"
        else:  # Unix/Linux/Mac
            pip_path = venv_path / "bin" / "pip"
        
        success, output = self._run_command([str(pip_path), "install", "-r", str(req_file)])
        
        if success:
            console.print("[green]âœ… Requirements installed successfully![/]")
            if output:
                # Show last few lines of output
                lines = output.strip().split('\n')
                if len(lines) > 5:
                    console.print("\n".join(lines[-5:]))
            logger.info(f"Installed requirements from {req_file}")
        else:
            console.print(f"[red]âŒ Failed to install requirements: {output}[/]")
            logger.error(f"Failed to install requirements: {output}")

    def _get_folder_size(self, folder_path: Path) -> int:
        """Calculate folder size in bytes.
        
        Args:
            folder_path: Path to folder.
            
        Returns:
            Size in bytes.
        """
        total_size = 0
        for item in folder_path.rglob('*'):
            if item.is_file():
                total_size += item.stat().st_size
        return total_size

    @staticmethod
    def _format_size(size_bytes: int) -> str:
        """Format size in human readable format.
        
        Args:
            size_bytes: Size in bytes.
            
        Returns:
            Formatted size string.
        """
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:.1f} {unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.1f} TB"

    def _run_command(self, cmd: List[str], shell: bool = False) -> Tuple[bool, str]:
        """Run a shell command.
        
        Args:
            cmd: Command list.
            shell: Whether to use shell.
            
        Returns:
            (success, output)
        """
        try:
            result = subprocess.run(
                cmd,
                shell=shell,
                capture_output=True,
                text=True,
                encoding='utf-8',
                errors='ignore'
            )
            
            if result.returncode == 0:
                return True, result.stdout.strip()
            else:
                error_msg = result.stderr.strip() or result.stdout.strip() or "Unknown error"
                logger.error(f"Command failed: {' '.join(cmd)} - {error_msg}")
                return False, error_msg
                
        except FileNotFoundError:
            error_msg = f"Command not found: {' '.join(cmd)}"
            logger.error(error_msg)
            return False, error_msg
        except Exception as e:
            logger.error(f"Command error: {e}")
            return False, str(e)

============================================================
ðŸ“„ FILE: src\mytools\tools\file_counter.py
============================================================
"""Count files and folders by extension and size."""
import os
from collections import defaultdict

from rich.table import Table
from rich.panel import Panel

from .base import BaseTool
# Assuming format_size is in your utils from the previous tool
from ..utils import console, logger, get_project_path, format_size

class FileCounterTool(BaseTool):
    name = "ðŸ“Š File Statistics"
    description = "Count files and folders by type and show size"

    def run(self) -> None:
        """Execute the file counting process."""
        console.clear()
        console.rule("[bold magenta]FILE STATISTICS[/]")

        project_path = get_project_path()

        # Folders that we don't want to count
        IGNORED_DIRS = {".git", "__pycache__", "node_modules", "venv", ".venv", ".idea"}

        # Dictionary to store both count and size for each extension
        file_stats = defaultdict(lambda: {"count": 0, "size": 0})
        total_files = 0
        total_dirs = 0
        total_size = 0

        # Scanning the directory
        with console.status("[cyan]Scanning project files...[/]", spinner="dots"):
            for root, dirs, files in os.walk(project_path):
                # Modify dirs in-place to skip ignored directories
                dirs[:] = [d for d in dirs if d not in IGNORED_DIRS]

                total_dirs += len(dirs)
                total_files += len(files)

                for file in files:
                    filepath = os.path.join(root, file)
                    ext = os.path.splitext(file)[1].lower() or "[no extension]"
                    
                    try:
                        size = os.path.getsize(filepath)
                    except OSError:
                        size = 0  # Ignore files that can't be read

                    file_stats[ext]["count"] += 1
                    file_stats[ext]["size"] += size
                    total_size += size

        # -----------------------------------------
        # DISPLAY RESULTS
        # -----------------------------------------
        
        # 1. Summary Panel
        summary_text = (
            f"ðŸ“ [bold]Project:[/] {os.path.basename(project_path)}\n"
            f"ðŸ“ [bold]Path:[/] [dim]{project_path}[/]\n\n"
            f"ðŸ“‚ [bold]Total Folders:[/] [cyan]{total_dirs}[/]\n"
            f"ðŸ“„ [bold]Total Files:[/] [cyan]{total_files}[/]\n"
            f"ðŸ’¾ [bold]Total Size:[/] [green]{format_size(total_size)}[/]"
        )
        console.print("\n")
        console.print(Panel(summary_text, title="ðŸŽ¯ Project Summary", border_style="blue", expand=False))

        # 2. Detailed Table by Extension
        table = Table(title="ðŸ“Š Files by Extension", header_style="bold magenta")
        table.add_column("Extension", style="cyan", no_wrap=True)
        table.add_column("File Count", justify="right", style="yellow")
        table.add_column("Total Size", justify="right", style="green")

        # Sort extensions by count (highest first)
        sorted_stats = sorted(file_stats.items(), key=lambda x: x[1]["count"], reverse=True)

        for ext, data in sorted_stats:
            table.add_row(
                ext,
                str(data["count"]),
                format_size(data["size"])
            )

        console.print("\n")
        console.print(table)

        console.input("\n[dim]Press Enter to continue...[/]")

============================================================
ðŸ“„ FILE: src\mytools\tools\file_ops.py
============================================================
"""Tool for file and folder operations."""
import os
import shutil
import stat
import time
from pathlib import Path
from typing import List

from rich.console import Console
from rich.prompt import Prompt, Confirm, IntPrompt
from rich.table import Table
from rich.panel import Panel

from .base import BaseTool
from ..utils import logger, get_project_path, format_size

class FileOperationsTool(BaseTool):
    """Perform file and folder operations."""

    name = "ðŸ“ File Operations"
    description = "List, copy, move, delete files and folders"

    def run(self) -> None:
        """Display file operations menu."""
        console = Console()
        
        while True:
            console.clear()
            console.rule("[bold cyan]ðŸ“ FILE OPERATIONS[/]")

            menu_text = (
                "[1] ðŸ“‹ List all project files (for copy path)\n"
                "[2] ðŸ“„ Copy file/folder\n"
                "[3] ðŸšš Move file/folder\n"
                "[4] ðŸ—‘ï¸  Delete file/folder\n"
                "[5] â„¹ï¸  File information\n"
                "[6] ðŸ“ Create new folder\n"
                "[7] ðŸ“ Create new file\n"
                "[8] ðŸšª Back to Main Menu"
            )
            console.print(Panel(menu_text, border_style="cyan", expand=False))

            choice = Prompt.ask("\n[bold cyan]Select an option[/]", choices=[str(i) for i in range(1, 9)])

            if choice == "1":
                self._list_project_files(console)
            elif choice == "2":
                self._copy_file_folder(console)
            elif choice == "3":
                self._move_file_folder(console)
            elif choice == "4":
                self._delete_file_folder(console)
            elif choice == "5":
                self._file_info(console)
            elif choice == "6":
                self._create_folder(console)
            elif choice == "7":
                self._create_file(console)
            elif choice == "8":
                break

            if choice != "8":
                console.input("\n[dim]Press Enter to continue...[/]")

    def _list_project_files(self, console: Console) -> None:
        console.clear()
        console.rule("[bold cyan]LIST PROJECT FILES[/]")

        current_dir = get_project_path()
        console.print(f"ðŸ“ [bold]Current directory:[/] [dim]{current_dir}[/]\n")

        all_files = []
        total_size = 0

        with console.status("[cyan]ðŸ” Scanning files...[/]", spinner="dots"):
            for root, dirs, files in os.walk(current_dir):
                dirs[:] = [d for d in dirs if not d.startswith(".")]

                for file in files:
                    if file.startswith("."):
                        continue

                    file_path = os.path.join(root, file)
                    try:
                        file_size = os.path.getsize(file_path)
                        rel_path = os.path.relpath(file_path, current_dir)
                        all_files.append({"path": rel_path, "size": file_size, "full_path": file_path})
                        total_size += file_size
                    except (OSError, PermissionError):
                        continue

        if not all_files:
            console.print("[red]âŒ No files found.[/]")
            return

        all_files.sort(key=lambda x: x["path"])
        console.print(f"ðŸ“Š [bold green]Found {len(all_files)} files[/] ({format_size(total_size)})")

        options = (
            "[1] Show all files with details\n"
            "[2] Show only file paths (for copying)\n"
            "[3] Search for specific files\n"
            "[4] Export list to file"
        )
        console.print(Panel(options, title="ðŸ“‹ Display options", expand=False))
        
        display_choice = Prompt.ask("Select option", choices=["1", "2", "3", "4"], default="1")

        if display_choice == "1":
            self._show_files_with_details(console, all_files)
        elif display_choice == "2":
            self._show_file_paths_only(console, all_files)
        elif display_choice == "3":
            self._search_files(console, all_files)
        elif display_choice == "4":
            self._export_file_list(console, all_files, current_dir)

    def _show_files_with_details(self, console: Console, files: List[dict]) -> None:
        table = Table(title="ðŸ“„ Files with details", header_style="bold magenta")
        table.add_column("No.", style="dim", width=6)
        table.add_column("Size", style="green", justify="right")
        table.add_column("Path", style="cyan")

        for idx, file_info in enumerate(files, 1):
            if idx <= 100:
                table.add_row(str(idx), format_size(file_info["size"]), file_info['path'])
            else:
                table.add_row("...", "...", f"[dim]and {len(files) - 100} more files[/]")
                break

        console.print(table)

        if files:
            console.print("\n[bold]ðŸ“‹ Copy options:[/]")
            choice = Prompt.ask("Enter file number to copy, 'a' for all, 'q' to quit", default="q").lower()

            if choice == "a":
                self._copy_all_paths(console, files)
            elif choice.isdigit():
                idx = int(choice) - 1
                if 0 <= idx < len(files):
                    self._copy_to_clipboard(files[idx]["path"])
                    console.print(f"âœ… [green]Copied:[/] {files[idx]['path']}")
                else:
                    console.print("[red]âŒ Invalid file number[/]")

    def _show_file_paths_only(self, console: Console, files: List[dict]) -> None:
        console.print("\n[bold]ðŸ“„ File paths only:[/]")
        for idx, file_info in enumerate(files[:50], 1):
            console.print(file_info['path'])
            
        if len(files) > 50:
            console.print(f"[dim]... and {len(files) - 50} more files[/]")

        if files and Confirm.ask("\nðŸ“‹ Copy all paths to file?"):
            self._copy_all_paths(console, files)

    def _search_files(self, console: Console, files: List[dict]) -> None:
        search_choice = Prompt.ask("\nðŸ” Search by", choices=["1", "2", "3"], default="1")
        # 1: Name, 2: Extension, 3: Size
        
        results = []
        if search_choice == "1":
            term = Prompt.ask("Enter filename part").lower()
            results = [f for f in files if term in f["path"].lower()]
        elif search_choice == "2":
            ext = Prompt.ask("Enter extension (e.g. .py)").lower()
            if not ext.startswith("."): ext = "." + ext
            results = [f for f in files if f["path"].lower().endswith(ext)]
        elif search_choice == "3":
            min_kb = IntPrompt.ask("Min size in KB", default=0) * 1024
            max_kb = IntPrompt.ask("Max size in KB (0 for no limit)", default=0) * 1024
            max_kb = max_kb if max_kb > 0 else float('inf')
            results = [f for f in files if min_kb <= f["size"] <= max_kb]

        if not results:
            console.print("[red]âŒ No files found.[/]")
            return

        console.print(f"\nðŸ“Š [bold green]{len(results)} files found[/]")
        self._show_files_with_details(console, results)

    def _export_file_list(self, console: Console, files: List[dict], current_dir: str) -> None:
        filename = Prompt.ask("\nEnter output filename", default="file_list.txt")
        fmt = Prompt.ask("Format [1] Simple [2] Detailed [3] CSV", choices=["1", "2", "3"], default="2")

        try:
            with open(filename, "w", encoding="utf-8") as f:
                if fmt == "3":
                    f.write("Path,Size(bytes),Size(human)\n")
                    for file in files:
                        f.write(f'"{file["path"]}",{file["size"]},"{format_size(file["size"])}"\n')
                else:
                    for file in files:
                        size_str = format_size(file["size"]) if fmt == "2" else ""
                        f.write(f"{size_str:<12} {file['path']}\n" if fmt == "2" else f"{file['path']}\n")

            console.print(f"âœ… [green]Exported to:[/] {os.path.abspath(filename)}")
        except Exception as e:
            console.print(f"[red]âŒ Export failed: {e}[/]")

    def _copy_all_paths(self, console: Console, files: List[dict]) -> None:
        all_paths = "\n".join(f["path"] for f in files)
        if self._copy_to_clipboard(all_paths):
            console.print(f"âœ… [green]Copied {len(files)} paths to clipboard[/]")
        else:
            console.print("[yellow]âš ï¸ Clipboard not available. Showing paths:[/]")
            console.print(all_paths[:500] + ("..." if len(all_paths) > 500 else ""))

    def _copy_file_folder(self, console: Console) -> None:
        console.clear()
        console.rule("[bold cyan]COPY FILE/FOLDER[/]")
        current_dir = get_project_path()

        source = Prompt.ask("Enter source path").strip()
        source = source if os.path.isabs(source) else os.path.join(current_dir, source)

        if not os.path.exists(source):
            console.print(f"[red]âŒ Source not found:[/] {source}")
            return

        dest_suggestion = f"copy_of_{os.path.basename(source)}"
        dest = Prompt.ask("Enter destination path", default=dest_suggestion).strip()
        dest = dest if os.path.isabs(dest) else os.path.join(current_dir, dest)

        if os.path.exists(dest) and not Confirm.ask("[yellow]Destination exists. Overwrite?[/]"):
            return

        if Confirm.ask(f"Confirm copy to {os.path.basename(dest)}?"):
            with console.status("[cyan]Copying...[/]"):
                try:
                    if os.path.isfile(source): shutil.copy2(source, dest)
                    else: shutil.copytree(source, dest, dirs_exist_ok=True)
                    console.print("âœ… [green]Copied successfully![/]")
                except Exception as e:
                    console.print(f"[red]âŒ Copy failed: {e}[/]")

    def _move_file_folder(self, console: Console) -> None:
        console.clear()
        console.rule("[bold cyan]MOVE FILE/FOLDER[/]")
        current_dir = get_project_path()

        source = Prompt.ask("Enter source path").strip()
        source = source if os.path.isabs(source) else os.path.join(current_dir, source)

        if not os.path.exists(source):
            console.print("[red]âŒ Source not found.[/]")
            return

        dest_dir = Prompt.ask("Enter destination directory").strip()
        dest_dir = dest_dir if os.path.isabs(dest_dir) else os.path.join(current_dir, dest_dir)

        if not os.path.exists(dest_dir) and Confirm.ask("Directory doesn't exist. Create it?"):
            os.makedirs(dest_dir, exist_ok=True)

        dest = os.path.join(dest_dir, os.path.basename(source))

        if Confirm.ask(f"Confirm move to {dest_dir}?"):
            with console.status("[cyan]Moving...[/]"):
                try:
                    shutil.move(source, dest)
                    console.print("âœ… [green]Moved successfully![/]")
                except Exception as e:
                    console.print(f"[red]âŒ Move failed: {e}[/]")

    def _delete_file_folder(self, console: Console) -> None:
        console.clear()
        console.rule("[bold red]DELETE FILE/FOLDER[/]")
        current_dir = get_project_path()

        target = Prompt.ask("Enter path to delete").strip()
        target = target if os.path.isabs(target) else os.path.join(current_dir, target)

        if not os.path.exists(target):
            console.print("[red]âŒ Path not found.[/]")
            return

        is_file = os.path.isfile(target)
        size = self._get_path_size(target)

        info = f"[bold]Path:[/] {target}\n[bold]Type:[/] {'File' if is_file else 'Folder'}\n[bold]Size:[/] {format_size(size)}"
        console.print(Panel(info, border_style="yellow"))

        important_paths = [os.path.expanduser("~"), "/", "C:\\", os.getcwd()]
        if any(target == p for p in important_paths):
            console.print("\n[bold red]âš ï¸ DANGER: You are trying to delete a critical system/project path![/]")
            if Prompt.ask("Type 'YES' to force delete") != "YES":
                return

        if Confirm.ask("[bold red]Are you absolutely sure you want to delete this?[/]"):
            with console.status("[red]Deleting...[/]"):
                try:
                    if is_file: os.remove(target)
                    else: shutil.rmtree(target, ignore_errors=True)
                    console.print(f"âœ… [green]Deleted:[/] {target}")
                except Exception as e:
                    console.print(f"[red]âŒ Deletion failed: {e}[/]")

    def _file_info(self, console: Console) -> None:
        console.clear()
        console.rule("[bold cyan]FILE INFORMATION[/]")
        target = Prompt.ask("Enter path").strip()
        
        if not os.path.exists(target):
            console.print("[red]âŒ Path not found.[/]")
            return

        path_obj = Path(target)
        size = self._get_path_size(target)
        
        table = Table(show_header=False, box=None)
        table.add_column("Key", style="bold cyan")
        table.add_column("Value")
        
        table.add_row("Name:", path_obj.name)
        table.add_row("Type:", "File" if path_obj.is_file() else "Folder")
        table.add_row("Size:", f"{format_size(size)} ({size:,} bytes)")
        table.add_row("Created:", time.ctime(os.path.getctime(target)))
        table.add_row("Modified:", time.ctime(os.path.getmtime(target)))
        
        console.print(Panel(table, title="â„¹ï¸ Details", expand=False))

    def _create_folder(self, console: Console) -> None:
        console.clear()
        console.rule("[bold cyan]CREATE FOLDER[/]")
        current_dir = get_project_path()

        name = Prompt.ask("Enter folder name").strip()
        path = name if os.path.isabs(name) else os.path.join(current_dir, name)

        if os.path.exists(path):
            console.print("[yellow]âš ï¸ Folder already exists.[/]")
            return

        try:
            os.makedirs(path, exist_ok=True)
            console.print(f"âœ… [green]Folder created:[/] {path}")
            if Confirm.ask("Create README.md inside?"):
                with open(os.path.join(path, "README.md"), "w") as f:
                    f.write(f"# {os.path.basename(name)}\n")
                console.print("âœ… [green]README.md created.[/]")
        except Exception as e:
            console.print(f"[red]âŒ Failed: {e}[/]")

    def _create_file(self, console: Console) -> None:
        console.clear()
        console.rule("[bold cyan]CREATE FILE[/]")
        current_dir = get_project_path()

        name = Prompt.ask("Enter file name (with ext)").strip()
        path = name if os.path.isabs(name) else os.path.join(current_dir, name)

        if os.path.exists(path) and not Confirm.ask("[yellow]File exists. Overwrite?[/]"):
            return

        os.makedirs(os.path.dirname(path) or ".", exist_ok=True)

        content_choice = Prompt.ask("Content [1] Empty [2] Template", choices=["1", "2"], default="2")
        content = self._get_file_template(os.path.splitext(name)[1].lower(), os.path.basename(name)) if content_choice == "2" else ""

        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write(content.strip())
            console.print(f"âœ… [green]File created:[/] {path}")
        except Exception as e:
            console.print(f"[red]âŒ Failed: {e}[/]")

    def _get_file_template(self, extension: str, filename: str) -> str:
        name = os.path.splitext(filename)[0]
        templates = {
            ".py": f'def main():\n    print("Hello from {name}")\n\nif __name__ == "__main__":\n    main()',
            ".html": f'<!DOCTYPE html>\n<html>\n<head><title>{name}</title></head>\n<body><h1>{name}</h1></body>\n</html>',
            ".js": f'console.log("{name} loaded");',
            ".md": f'# {name}\n\nDescription here.',
            ".json": '{\n    "key": "value"\n}'
        }
        return templates.get(extension, "")

    @staticmethod
    def _get_path_size(path: str) -> int:
        if os.path.isfile(path): return os.path.getsize(path)
        return sum(os.path.getsize(os.path.join(d, f)) for d, _, fs in os.walk(path) for f in fs if os.path.exists(os.path.join(d, f)))

    @staticmethod
    def _copy_to_clipboard(text: str) -> bool:
        try:
            import pyperclip
            pyperclip.copy(text)
            return True
        except: return False

============================================================
ðŸ“„ FILE: src\mytools\tools\__init__.py
============================================================
"""Tool plugin loader â€“ fallback if entry points not used."""
from pathlib import Path
import importlib.util
import inspect
import sys
from .base import BaseTool

def discover_tools(tool_dir=None):
    """Scan tools directory and load all subclasses of BaseTool."""
    if tool_dir is None:
        tool_dir = Path(__file__).parent
    tools = {}
    for file in tool_dir.glob("*.py"):
        if file.name == "__init__.py" or file.name == "base.py":
            continue
        module_name = f"mytools.tools.{file.stem}"
        spec = importlib.util.spec_from_file_location(module_name, file)
        if spec and spec.loader:
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            for name, obj in inspect.getmembers(module):
                if (inspect.isclass(obj) and issubclass(obj, BaseTool)
                        and obj != BaseTool):
                    tools[file.stem] = obj
    return tools

============================================================
ðŸ“„ FILE: tests\conftest.py
============================================================
"""Pytest configuration and fixtures."""
import pytest
import tempfile
import os
from pathlib import Path
from typer.testing import CliRunner

@pytest.fixture
def cli_runner():
    """Provide a Typer CLI test runner."""
    return CliRunner()

@pytest.fixture
def temp_project():
    """Create a temporary project directory for testing."""
    with tempfile.TemporaryDirectory() as tmpdir:
        old_cwd = os.getcwd()
        os.chdir(tmpdir)
        yield Path(tmpdir)
        os.chdir(old_cwd)

@pytest.fixture
def sample_pycache_folder(temp_project):
    """Create a sample __pycache__ folder with files."""
    pycache = temp_project / "__pycache__"
    pycache.mkdir()
    (pycache / "test.pyc").write_text("test content")
    (pycache / "module.pyc").write_text("module content")
    return pycache

============================================================
ðŸ“„ FILE: tests\test_cli.py
============================================================
"""Test CLI commands and plugins."""
import pytest
from typer.testing import CliRunner
from mytools.cli import app

def test_cli_help(cli_runner):
    """Test that CLI help works."""
    result = cli_runner.invoke(app, ["--help"])
    assert result.exit_code == 0
    assert "MyTools" in result.stdout
    assert "Commands" in result.stdout

def test_list_command(cli_runner):
    """Test list command shows all tools."""
    result = cli_runner.invoke(app, ["list"])
    assert result.exit_code == 0
    assert "clean-pycache" in result.stdout
    assert "django" in result.stdout
    assert "env" in result.stdout

def test_info_command(cli_runner):
    """Test info command shows system information."""
    result = cli_runner.invoke(app, ["info"])
    assert result.exit_code == 0
    assert "MyTools version" in result.stdout
    assert "Python" in result.stdout

def test_invalid_command(cli_runner):
    """Test invalid command shows error."""
    result = cli_runner.invoke(app, ["invalid-command"])
    assert result.exit_code != 0

============================================================
ðŸ“„ FILE: tests\test_tools\test_clean_pycache.py
============================================================
"""Test clean_pycache tool."""
import pytest
import os
from pathlib import Path
from mytools.tools.clean_pycache import CleanPycacheTool
from mytools.utils import format_size

class TestCleanPycacheTool:
    """Test cases for CleanPycacheTool."""
    
    def test_folder_size_calculation(self, sample_pycache_folder):
        """Test that folder size is calculated correctly."""
        tool = CleanPycacheTool()
        size = tool._folder_size(sample_pycache_folder)
        assert size > 0
        assert size == len("test content") + len("module content")
    
    def test_folder_size_empty_folder(self, temp_project):
        """Test empty folder returns 0 size."""
        tool = CleanPycacheTool()
        empty_folder = temp_project / "empty"
        empty_folder.mkdir()
        size = tool._folder_size(empty_folder)
        assert size == 0
    
    def test_folder_size_nonexistent(self, temp_project):
        """Test nonexistent folder returns 0."""
        tool = CleanPycacheTool()
        nonexistent = temp_project / "does_not_exist"
        size = tool._folder_size(nonexistent)
        assert size == 0
    
    def test_format_size_bytes(self):
        """Test format_size with bytes."""
        assert format_size(500) == "500.00 B"
    
    def test_format_size_kilobytes(self):
        """Test format_size with KB."""
        assert format_size(1024) == "1.00 KB"
        assert format_size(2048) == "2.00 KB"
    
    def test_format_size_megabytes(self):
        """Test format_size with MB."""
        assert format_size(1048576) == "1.00 MB"
        assert format_size(2097152) == "2.00 MB"
    
    def test_format_size_gigabytes(self):
        """Test format_size with GB."""
        assert format_size(1073741824) == "1.00 GB"
    
    @pytest.mark.skipif(os.name == 'nt', reason="Permission test different on Windows")
    def test_permission_error_handling(self, temp_project):
        """Test handling of permission errors."""
        # This is a simplified test - actual permission testing is complex
        tool = CleanPycacheTool()
        protected = temp_project / "protected"
        protected.mkdir()
        # Don't actually set permissions in test
        assert tool._folder_size(protected) == 0

============================================================
ðŸ“„ FILE: tests\test_tools\test_env_manager.py
============================================================
"""Test env_manager tool."""
import pytest
import os
from pathlib import Path
from mytools.tools.env_manager import EnvTool

class TestEnvTool:
    """Test cases for EnvTool."""
    
    def test_create_env_file(self, temp_project):
        """Test .env file creation."""
        tool = EnvTool()
        env_file = temp_project / ".env"
        
        # Mock user input
        with pytest.MonkeyPatch.context() as mp:
            mp.setattr('builtins.input', lambda _: 'n')  # Don't overwrite
            # Call the method directly (simplified for testing)
            # Full testing would require more mocking
        
        assert True  # Placeholder
    
    def test_detect_existing_venv(self, temp_project):
        """Test detection of existing virtual environment."""
        # Create fake venv structure
        venv_dir = temp_project / ".venv"
        venv_dir.mkdir()
        (venv_dir / "Scripts").mkdir(exist_ok=True)
        (venv_dir / "Lib").mkdir(exist_ok=True)
        
        tool = EnvTool()
        # Test detection logic here
        assert venv_dir.exists()

============================================================
ðŸ“„ FILE: tests\test_tools\test_file_counter.py
============================================================
"""Test file_counter tool."""
import pytest
from pathlib import Path
from mytools.tools.file_counter import FileCounterTool

class TestFileCounterTool:
    """Test cases for FileCounterTool."""
    
    def test_file_extension_counting(self, temp_project):
        """Test counting files by extension."""
        # Create test files
        (temp_project / "test1.py").write_text("print('hello')")
        (temp_project / "test2.py").write_text("print('world')")
        (temp_project / "readme.md").write_text("# README")
        (temp_project / "config.json").write_text('{"key": "value"}')
        
        # Create subfolder with more files
        subdir = temp_project / "subdir"
        subdir.mkdir()
        (subdir / "test3.py").write_text("print('sub')")
        
        tool = FileCounterTool()
        # Test counting logic
        # Note: We're testing the counting logic, not the full run() method
        
        # Count .py files manually
        py_files = list(temp_project.rglob("*.py"))
        assert len(py_files) == 3
        
        # Count .md files
        md_files = list(temp_project.rglob("*.md"))
        assert len(md_files) == 1
    
    def test_empty_directory(self, temp_project):
        """Test empty directory."""
        tool = FileCounterTool()
        # Should not crash
        assert temp_project.exists()

============================================================
ðŸ“„ FILE: tests\test_tools\test_file_ops.py
============================================================
import os
import pytest
from pathlib import Path
from unittest.mock import patch, MagicMock

# Note: Yahan import path apne project ke structure ke hisab se adjust kar lena
# Example: from mytools.tools.file_ops_tool import FileOperationsTool
from mytools.tools.file_ops import FileOperationsTool


@pytest.fixture
def mock_project_path(tmp_path):
    """Temporary directory ko project path ki tarah mock karta hai."""
    # Slashes (/) ki jagah Dots (.) use karne hain, aur sahi module ko point karna hai.
    with patch("mytools.tools.file_ops.get_project_path", return_value=str(tmp_path)):
        yield str(tmp_path)

@pytest.fixture
def tool():
    """Tool ka instance return karta hai."""
    return FileOperationsTool()

@pytest.fixture
def mock_console():
    """Console clears aur prints ko mock karta hai taaki test output clean rahe."""
    with patch("rich.console.Console.clear"), patch("rich.console.Console.print"), patch("rich.console.Console.rule"):
        yield

def test_menu_exit(tool, mock_console):
    """Test karta hai ki '8' dabane par menu gracefully exit hota hai."""
    with patch("rich.prompt.Prompt.ask", return_value="8"):
        tool.run()  # Loop break ho jayega aur test pass ho jayega

def test_create_folder(tool, mock_project_path, mock_console):
    """Test karta hai ki naya folder aur uske andar README.md properly create hota hai."""
    folder_name = "test_directory"
    
    # Prompt.ask ko "test_directory" return karne ke liye mock kiya
    # Confirm.ask ko True return karne ke liye mock kiya (Create README.md? -> Yes)
    with patch("rich.prompt.Prompt.ask", return_value=folder_name), \
         patch("rich.prompt.Confirm.ask", return_value=True):
        
        console = MagicMock()
        tool._create_folder(console)
        
        created_dir = Path(mock_project_path) / folder_name
        readme_file = created_dir / "README.md"
        
        assert created_dir.exists()
        assert created_dir.is_dir()
        assert readme_file.exists()
        assert readme_file.read_text() == f"# {folder_name}\n"

def test_create_file_with_template(tool, mock_project_path, mock_console):
    """Test karta hai ki naya Python file template ke sath create hota hai."""
    file_name = "script.py"
    
    # Sequence of prompts:
    # 1. Enter file name -> "script.py"
    # 2. Content choice -> "2" (Template)
    with patch("rich.prompt.Prompt.ask", side_effect=[file_name, "2"]):
        
        console = MagicMock()
        tool._create_file(console)
        
        created_file = Path(mock_project_path) / file_name
        assert created_file.exists()
        
        content = created_file.read_text()
        assert "def main():" in content
        assert "print(\"Hello from script\")" in content

def test_delete_file(tool, mock_project_path, mock_console):
    """Test karta hai ki file successfully delete hoti hai jab user confirm karta hai."""
    # Pehle ek temporary file banate hain
    test_file = Path(mock_project_path) / "to_delete.txt"
    test_file.write_text("dummy content")
    assert test_file.exists()

    # Prompts:
    # 1. Enter path to delete -> "to_delete.txt"
    # 2. Confirm deletion -> True
    with patch("rich.prompt.Prompt.ask", return_value="to_delete.txt"), \
         patch("rich.prompt.Confirm.ask", return_value=True):
        
        console = MagicMock()
        tool._delete_file_folder(console)
        
        # Verify file is deleted
        assert not test_file.exists()

def test_copy_file(tool, mock_project_path, mock_console):
    """Test karta hai ki ek file dusri jagah properly copy hoti hai."""
    source_file = Path(mock_project_path) / "source.txt"
    source_file.write_text("Hello World")
    
    dest_file_name = "dest.txt"
    dest_file = Path(mock_project_path) / dest_file_name

    # Prompts:
    # 1. Enter source path -> "source.txt"
    # 2. Enter dest path -> "dest.txt"
    # 3. Confirm copy -> True
    with patch("rich.prompt.Prompt.ask", side_effect=["source.txt", dest_file_name]), \
         patch("rich.prompt.Confirm.ask", return_value=True):
        
        console = MagicMock()
        tool._copy_file_folder(console)
        
        assert dest_file.exists()
        assert dest_file.read_text() == "Hello World"

============================================================
ðŸ“„ FILE: tests\test_tools\test_sample.py
============================================================
# test_sample.py

def jodna(x, y):
    return x + y

def test_jodna_function():
    # Yahan hum check kar rahe hain ki 2 aur 3 milakar 5 hote hain ya nahi
    assert jodna(2, 3) == 5
    assert jodna(-1, 1) == 0


============================================================
ðŸ’¡ FOR AI ASSISTANT:
This is the complete context of the project. Please analyze the structure
and code to provide accurate assistance. Key files include configuration
files, source code, and documentation.

When responding, reference specific files and paths from the structure above.


YOUR TASK:
Based on the project structure and code above, please:
1. Understand the project architecture and main components.
2. Identify key files, dependencies, and configuration.
3. Provide specific, actionable advice or code.

My specific request is: [DESCRIBE WHAT YOU NEED HELP WITH HERE]

Please reference specific files and paths from the project structure in your response. Be detailed but concise.